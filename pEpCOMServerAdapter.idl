// pEpCOMServerAdapter.idl : IDL source for pEpCOMServerAdapter
//

// This file will be processed by the MIDL tool to
// produce the type library (pEpCOMServerAdapter.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";

[
    object,
    uuid(9A9F4422-CF0A-45D7-90CD-1D1B7B2A4540),
    oleautomation,
    nonextensible,
    pointer_default(unique)
]
interface IpEpEngine : IUnknown {
    HRESULT verbose_logging([in] BOOL enable);

    typedef   enum _pEp_STATUS {
        pEp_STATUS_OK = 0,

        pEp_KEY_NOT_FOUND = 0x0201,
        pEp_KEY_HAS_AMBIG_NAME = 0x0202,
        pEp_GET_KEY_FAILED = 0x0203,

        pEp_UNENCRYPTED = 0x0400,
        pEp_VERIFIED = 0x0401,
        pEp_DECRYPTED = 0x0402,
        pEp_DECRYPTED_AND_VERIFIED = 0x0403,
        pEp_DECRYPT_WRONG_FORMAT = 0x0404,
        pEp_DECRYPT_NO_KEY = 0x0405,
        pEp_DECRYPT_SIGNATURE_DOES_NOT_MATCH = 0x0406,
        pEp_VERIFY_NO_KEY = 0x0407,
        pEp_VERIFIED_AND_TRUSTED = 0x0408,

        pEp_ILLEGAL_VALUE = -4,
        pEp_BUFFER_TOO_SMALL = -3,
        pEp_OUT_OF_MEMORY = -2,
        pEp_UNKNOWN_ERROR = -1
    } pEp_STATUS;

    HRESULT log([in] BSTR title, [in] BSTR entity, [in, defaultvalue("")] BSTR description, [in, defaultvalue("")] BSTR comment);
    HRESULT decrypt([in] BSTR ctext, [out] BSTR * ptext, [out] SAFEARRAY(BSTR) * key_list, [out, retval] pEp_STATUS * decrypt_status);
    HRESULT decrypt_b([in] BSTR ctext, [out] SAFEARRAY(BYTE) * ptext, [out] SAFEARRAY(BSTR) * key_list, [out, retval] pEp_STATUS * decrypt_status);
    HRESULT encrypt([in] SAFEARRAY(BSTR) key_list, [in] BSTR ptext, [out] BSTR * ctext, [out, retval] pEp_STATUS * status);
    HRESULT encrypt_b([in] SAFEARRAY(BSTR) key_list, [in] SAFEARRAY(BYTE) ptext, [out] BSTR * ctext, [out, retval] pEp_STATUS * status);
    HRESULT verify([in] BSTR text, [in] BSTR signature, [out] SAFEARRAY(BSTR) * key_list, [out, retval] pEp_STATUS * verify_status);
    HRESULT trustword([in] LONG value, [in, defaultvalue("en")] BSTR lang, [out, retval] BSTR * word);
    HRESULT trustwords([in] BSTR fpr, [in, defaultvalue("en")] BSTR lang, [in, defaultvalue(0)] LONG max_words, [out, retval] BSTR * words);

    typedef enum _pEp_comm_type {
        pEp_ct_unknown = 0,

        // range 0x01 to 0x09: no encryption, 0x0a to 0x0e: nothing reasonable

        pEp_ct_no_encryption = 0x01,                // generic
        pEp_ct_no_encrypted_channel = 0x02,
        pEp_ct_key_not_found = 0x03,
        pEp_ct_key_expired = 0x04,
        pEp_ct_key_revoked = 0x05,
        pEp_ct_key_b0rken = 0x06,
        pEp_ct_my_key_not_included = 0x09,

        pEp_ct_security_by_obscurity = 0x0a,
        pEp_ct_b0rken_crypto = 0x0b,
        pEp_ct_key_too_short = 0x0e,

        pEp_ct_compromized = 0x0f,                  // known compromized connection

        // range 0x10 to 0x3f: unconfirmed encryption

        pEp_ct_unconfirmed_encryption = 0x10,       // generic
        pEp_ct_OpenPGP_1024_RSA_unconfirmed = 0x11,	// RSA 1024 is weak
        pEp_ct_OpenPGP_unconfirmed = 0x3f,          // key at least 2048 bit RSA
        // or 1024 bit DSA

        // range 0x40 to 0x7f: unconfirmed encryption and anonymization

        pEp_ct_unconfirmed_enc_anon = 0x40,         // generic
        pEp_ct_pEp_unconfirmed = 0x7f,

        pEp_ct_confirmed = 0x80,                    // this bit decides if trust is confirmed

        // range 0x81 to 0x8f: reserved
        // range 0x90 to 0xbf: confirmed encryption

        pEp_ct_confirmed_encryption = 0x90,         // generic
        pEp_ct_OpenPGP_1024_RSA = 0x91, // RSA 1024 is weak
        pEp_ct_OpenPGP = 0xbf, // key at least 2048 bit RSA or 1024 bit DSA

        // range 0xc0 to 0xff: confirmed encryption and anonymization

        pEp_ct_confirmed_enc_anon = 0xc0,           // generic
        pEp_ct_pEp = 0xff
    } pEp_comm_type;

    [uuid(0CB90E62-8A6A-4CA0-99D7-481704051FF0)] struct pEp_identity_s {
        BSTR address;
        BSTR fpr;
        BSTR user_id;
        BSTR username;
        pEp_comm_type comm_type;
        BSTR lang;
    };

    HRESULT get_identity([in] BSTR address, [out, retval] struct pEp_identity_s * ident);
    HRESULT set_identity([in] struct pEp_identity_s * ident);
    HRESULT generate_keypair([in] struct pEp_identity_s * ident, [out, retval] BSTR * fpr);
    HRESULT delete_keypair([in] BSTR fpr);
    HRESULT import_key([in] BSTR key_data);
    HRESULT import_key_b([in] SAFEARRAY(BYTE) key_data);
    HRESULT export_key([in] BSTR fpr, [out, retval] BSTR * key_data);
    HRESULT recv_key([in] BSTR pattern);
    HRESULT find_keys([in] BSTR pattern, [out, retval] SAFEARRAY(BSTR) * key_list);
    HRESULT send_key([in] BSTR pattern);

    HRESULT start_keyserver_lookup();
    HRESULT stop_keyserver_lookup();

    HRESULT examine_identity([in] struct pEp_identity_s * ident);
    HRESULT myself([in] struct pEp_identity_s *ident, [out, retval] struct pEp_identity_s *result);
    HRESULT update_identity([in] struct pEp_identity_s *ident, [out, retval] struct pEp_identity_s *result);
    HRESULT key_compromized([in] struct pEp_identity_s *ident);
    HRESULT reset_trust([in] struct pEp_identity_s *ident);
    HRESULT trust_personal_key([in] struct pEp_identity_s *ident, [out, retval] struct pEp_identity_s *result);

    // Message API

    typedef enum _pEp_color {
        pEp_rating_undefined = 0,
        pEp_rating_cannot_decrypt,
        pEp_rating_have_no_key,
        pEp_rating_unencrypted,
        pEp_rating_unreliable,
        pEp_rating_reliable,
        pEp_rating_yellow = pEp_rating_reliable,
        pEp_rating_trusted,
        pEp_rating_green = pEp_rating_trusted,
        pEp_rating_trusted_and_anonymized,
        pEp_rating_fully_anonymous,

        pEp_rating_under_attack = -1,
        pEp_rating_red = pEp_rating_under_attack,
        pEp_rating_b0rken = -2
    } pEp_color;

    typedef enum _pEp_text_format {
        pEp_text_format_plain = 0,
        pEp_text_format_html,
        pEp_text_format_other = 0xff
    } pEp_text_format;

    typedef  enum _pEp_msg_direction {
        pEp_dir_incoming = 0,
        pEp_dir_outgoing
    } pEp_msg_direction;

    typedef  enum _pEp_MIME_format {
        pEp_MIME_none = 0,                      // message is not MIME encoded
        pEp_MIME_fields_omitted,                // message content but no fields
        pEp_MIME                                // message is fully MIME encoded
    } pEp_MIME_format;

    typedef  enum _pEp_enc_format {
        pEp_enc_none = 0,                       // message is not encrypted
        pEp_enc_pieces,                         // inline PGP + PGP extensions
        pEp_enc_S_MIME,                         // RFC5751
        pEp_enc_PGP_MIME,                       // RFC3156
        pEp_enc_pEp                             // pEp encryption format
    } pEp_enc_format;

    [uuid(3A8A4F13-3402-4C4C-94AB-598D87869380)] struct opt_field {
        BSTR name;
        BSTR value;
    };

    [uuid(61DA7AD4-192E-4616-8678-B19AEFB45B45)] struct blob {
        SAFEARRAY(BYTE) value;
        BSTR mime_type;
        BSTR filename;
    };

    [uuid(D763A8F3-BA23-4229-A037-1BB7BDC3E0C8)] struct text_message {
        pEp_msg_direction dir;
        BSTR id;
        BSTR shortmsg;
        BSTR longmsg;
        BSTR longmsg_formatted;
        SAFEARRAY(struct blob) attachments;
        hyper sent;
        hyper recv;
        struct pEp_identity_s from;
        SAFEARRAY(struct pEp_identity_s) to;
        struct pEp_identity_s recv_by;
        SAFEARRAY(struct pEp_identity_s) cc;
        SAFEARRAY(struct pEp_identity_s) bcc;
        SAFEARRAY(struct pEp_identity_s) reply_to;
        SAFEARRAY(BSTR) references;
        SAFEARRAY(BSTR) keywords;
        BSTR comments;
        SAFEARRAY(struct opt_field) opt_fields;
    };

    HRESULT encrypt_message([in] struct text_message *src, [out] struct text_message * dst, [in] SAFEARRAY(BSTR) extra);
    HRESULT decrypt_message([in] struct text_message *src, [out] struct text_message * dst, [out] SAFEARRAY(BSTR) *keylist, [out, retval] pEp_color *rating);
    HRESULT outgoing_message_color([in] struct text_message *msg, [out, retval] pEp_color * pVal);
    HRESULT identity_color([in] struct pEp_identity_s * ident, [out, retval] pEp_color * pVal);
};

[
    uuid(3EC2E1A4-40E8-48E4-A7B0-1876D34F9462),
    version(1.0),
]
library pEpCOMServerAdapterLib
{
    importlib("stdole2.tlb");
    [
        uuid(B6BC9B8E-D9E2-4419-A3A4-7B4B58175549)
    ]
    dispinterface _IpEpEngineEvents
    {
    properties:
    methods:
    };
    [
        uuid(EF1B073D-5058-4E0E-829E-B4D22CA21EA2)
    ]
    coclass pEpEngine {
        [default] interface IpEpEngine;
        [default, source] dispinterface _IpEpEngineEvents;
    };
};
