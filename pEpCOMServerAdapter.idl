// pEpCOMServerAdapter.idl : IDL source for pEpCOMServerAdapter
//

// This file will be processed by the MIDL tool to
// produce the type library (pEpCOMServerAdapter.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";

[
    object,
    uuid(4DA92647-A858-448E-B01F-BE4DCB8C86A1),
    oleautomation,
    nonextensible,
    pointer_default(unique)
]
interface IpEpEngineCallbacks : IUnknown {

    typedef [v1_enum] enum SyncHandshakeResult {
        SyncHandshakeCancel = -1,
        SyncHandshakeAccepted = 0,
        SyncHandshakeRejected = 1
    } SyncHandshakeResult;

    [id(1)] HRESULT MessageToSend([in] struct TextMessage * msg);
    [id(2)] HRESULT ShowHandshake([in] struct pEpIdentity * self, [in] struct pEpIdentity * partner, [out, retval] SyncHandshakeResult * result);
};


[
    object,
    uuid(045E49AF-0975-4876-A53B-8CA5AB28C0F8),
    oleautomation,
    nonextensible,
    pointer_default(unique)
]
interface IpEpEngine : IUnknown {

    // runtime config of the adapter

    HRESULT VerboseLogging([in] VARIANT_BOOL enable);

    // runtime config of the engine

    HRESULT PassiveMode([in] VARIANT_BOOL enable);
    HRESULT UnencryptedSubject([in] VARIANT_BOOL enable);

    // basic API

    HRESULT ExportKey([in] BSTR fpr, [out, retval] BSTR * keyData);
    HRESULT Log([in] BSTR title, [in] BSTR entity, [in, defaultvalue("")] BSTR description, [in, defaultvalue("")] BSTR comment);
    HRESULT TrustWords([in] BSTR fpr, [in, defaultvalue("en")] BSTR lang, [in, defaultvalue(0)] LONG maxWords, [out, retval] BSTR * words);
    HRESULT GetCrashdumpLog([in, defaultvalue(0)] LONG maxlines, [out, retval] BSTR * log);
    HRESULT GetEngineVersion([out, retval] BSTR * engineVersion);
    HRESULT GetLanguageList([out, retval] BSTR * languages);

    typedef [v1_enum] enum pEpComType {
        pEpCtUnknown = 0,

        // range 0x01 to 0x09: no encryption, 0x0a to 0x0e: nothing reasonable

        pEpCtNoEncryption = 0x01,                // generic
        pEpCtNoEncryptedChannel = 0x02,
        pEpCtKeyNotFound = 0x03,
        pEpCtKeyExpired = 0x04,
        pEpCtKeyRevoked = 0x05,
        pEpCtKeyB0rken = 0x06,
        pEpCtMyKeyNotIncluded = 0x09,

        pEpCtSecurityByObscurity = 0x0a,
        pEpCtB0rkenCrypto = 0x0b,
        pEpCtKeyTooShort = 0x0c,

        pEpCtCompromised = 0x0e,                 // known compromized connection
        pEpCtMistrusted = 0x0f,                  // known mistrusted key

        // range 0x10 to 0x3f: unconfirmed encryption

        pEpCtUnconfirmedEncryption = 0x10,       // generic
        pEpCtOpenPGPWeakUnconfirmed = 0x11,      // RSA 1024 is weak

        pEpCtToBeChecked = 0x20,                 // generic
        pEpCtSMIMEUnconfirmed = 0x21,
        pEpCtCMSUnconfirmed = 0x22,

        pEpCtStrongButUnconfirmed = 0x30,        // generic
        pEpCtOpenPGPUnconfirmed = 0x38,          // key at least 2048 bit RSA or EC
        pEpCtOTRUnconfirmed = 0x3a,

        // range 0x40 to 0x7f: unconfirmed encryption and anonymization

        pEpCtUnconfirmedEncAnon = 0x40,          // generic
        pEpCtpEpUnconfirmed = 0x7f,

        pEpCtConfirmed = 0x80,                   // this bit decides if trust is confirmed

        // range 0x81 to 0x8f: reserved
        // range 0x90 to 0xbf: confirmed encryption

        pEpCtConfirmedEncryption = 0x90,         // generic
        pEpCtOpenPGPWeak = 0x91,                 // RSA 1024 is weak

        pEpCtToBeCheckedConfirmed = 0xa0,        // generic
        pEpCtSMIME = 0xa1,
        pEpCtCMS = 0xa2,

        pEpCtStrongEncryption = 0xb0,            // generic
        pEpCtOpenPGP = 0xb8,                     // key at least 2048 bit RSA or EC
        pEpCtOTR = 0xba,

        // range 0xc0 to 0xff: confirmed encryption and anonymization

        pEpCtConfirmedEncAnon = 0xc0,            // generic
        pEpCtpEp = 0xff
    } pEpComType;

    [uuid(C3A3814E-567F-4D1C-9F44-9B1DA3957A89)] struct pEpIdentity {
        BSTR Address;
        BSTR Fpr;
        BSTR UserId;
        BSTR UserName;
        pEpComType CommType;
        BSTR Lang;
    };

    // Keymanagement API

    HRESULT StartKeyserverLookup();
    HRESULT StopKeyserverLookup();

    HRESULT Myself([in] struct pEpIdentity *ident, [out, retval] struct pEpIdentity *result);
    HRESULT UpdateIdentity([in] struct pEpIdentity *ident, [out, retval] struct pEpIdentity *result);
    HRESULT KeyMistrusted([in] struct pEpIdentity *ident);
    HRESULT KeyResetTrust([in] struct pEpIdentity *ident);
    HRESULT TrustPersonalKey([in] struct pEpIdentity *ident, [out, retval] struct pEpIdentity *result);

    // Blacklist API

    HRESULT BlacklistAdd([in] BSTR fpr);
    HRESULT BlacklistDelete([in] BSTR fpr);
    HRESULT BlacklistIsListed([in] BSTR fpr, [out, retval] VARIANT_BOOL *listed);
    HRESULT BlacklistRetrieve([out, retval] SAFEARRAY(BSTR) *blacklist);

    // PGP compatibility functions

    HRESULT OpenPGPListKeyinfo([in] BSTR searchPattern, [out, retval] SAFEARRAY(struct StringPair)* keyinfoList);

    // Message API

    typedef [v1_enum] enum pEpRating {
        pEpRatingUndefined = 0,
        pEpRatingCannotDecrypt,
        pEpRatingHaveNoKey,
        pEpRatingUnencrypted,
        pEpRatingUnencryptedForSome,
        pEpRatingUnreliable,
        pEpRatingReliable,
        pEpRatingTrusted,
        pEpRatingTrustedAndAnonymized,
        pEpRatingFullyAnonymous,

        pEpRatingMistrust = -1,
        pEpRatingB0rken = -2,
        pEpRatingUnderAttack = -3
    } pEpRating;

    typedef [v1_enum] enum pEpColor {
        pEpColorNoColor = 0,
        pEpColorYellow,
        pEpColorGreen,
        pEpColorRed = -1,
    } pEpColor;

    typedef [v1_enum] enum pEpEncryptFlags {
        pEpEncryptFlagsNone = 0,
        pEpEncryptFlagForceEncryption = 0x1,
    } pEpEncryptFlags;

    typedef [v1_enum] enum pEpDecryptFlags {
        pEpDecryptFlagsNone = 0,
        pEpDecryptFlagOwnPrivateKey = 0x1
    } pEpDecryptFlags;

    typedef [v1_enum] enum pEpMsgDirection {
        pEpDirIncoming = 0,
        pEpDirOutgoing
    } pEpMsgDirection;

    [uuid(47FB0795-6B64-455C-BB0E-54998CAB8ACB)] struct StringPair {
        BSTR Name;
        BSTR Value;
    };

    [uuid(634EB7CE-99AA-460D-BDF8-F7CDA7232CA6)] struct Blob {
        SAFEARRAY(BYTE) value;
        BSTR MimeType;
        BSTR Filename;
    };

    [uuid(B6F40887-E761-4A47-B204-A0193EE0284D)] struct TextMessage {
        pEpMsgDirection Dir;
        BSTR Id;
        BSTR ShortMsg;
        BSTR LongMsg;
        BSTR LongMsgFormatted;
        SAFEARRAY(struct Blob) Attachments;
        hyper Sent; // Timestamp: 64 Bit time_t from mktime(), seconds since January 1, 1970, 0:00 UTC.
        hyper Recv; // Timestamp: 64 Bit time_t from mktime(), seconds since January 1, 1970, 0:00 UTC.
        struct pEpIdentity From;
        SAFEARRAY(struct pEpIdentity) To;
        struct pEpIdentity RecvBy;
        SAFEARRAY(struct pEpIdentity) Cc;
        SAFEARRAY(struct pEpIdentity) Bcc;
        SAFEARRAY(struct pEpIdentity) ReplyTo;
        SAFEARRAY(BSTR) References;
        SAFEARRAY(BSTR) Keywords;
        BSTR Comments;
        SAFEARRAY(struct StringPair) OptFields;
    };

    HRESULT EncryptMessage([in] struct TextMessage *src, [out] struct TextMessage * dst, [in] SAFEARRAY(BSTR) extra, [in, defaultvalue(pEpEncryptFlagsNone)] pEpEncryptFlags flags);
    HRESULT DecryptMessage([in] struct TextMessage *src, [out] struct TextMessage * dst, [out] SAFEARRAY(BSTR) *keylist, [out] pEpDecryptFlags* flags, [out, retval] pEpRating *rating);

    HRESULT OutgoingMessageRating([in] struct TextMessage *msg, [out, retval] pEpRating * pVal);
    HRESULT IdentityRating([in] struct pEpIdentity * ident, [out, retval] pEpRating * pVal);
    HRESULT ColorFromRating([in] pEpRating rating, [out, retval] pEpColor* pVal);

    // callback / keysync API
    HRESULT RegisterCallbacks([in] IpEpEngineCallbacks* newCallback);
    HRESULT UnregisterCallbacks([in] IpEpEngineCallbacks* obsoleteCallback);
};

[
    uuid(564A4350-419E-47F1-B0DF-6FCCF0CD0BBC),
    version(1.0),
]
library pEpCOMServerAdapterLib
{
    importlib("stdole2.tlb");

    [
        uuid(5FF6682B-727B-4DFE-A68D-28982874C0C7)
    ]
    coclass pEpEngine {
        [default] interface IpEpEngine;
    };
};
