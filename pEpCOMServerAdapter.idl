// pEpCOMServerAdapter.idl : IDL source for pEpCOMServerAdapter
//

// This file will be processed by the MIDL tool to
// produce the type library (pEpCOMServerAdapter.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";

[
    object,
    uuid(9A9F4422-CF0A-45D7-90CD-1D1B7B2A4540),
    oleautomation,
    nonextensible,
    pointer_default(unique)
]
interface IpEpEngine : IUnknown {
    // runtime config of the adapter

    HRESULT verbose_logging([in] VARIANT_BOOL enable);

    // runtime config of the engine

    HRESULT passive_mode([in] VARIANT_BOOL enable);
    HRESULT unencrypted_subject([in] VARIANT_BOOL enable);

    // basic API

    typedef enum _pEp_STATUS {
        pEp_STATUS_OK = 0,

        pEp_INIT_CANNOT_LOAD_GPGME = 0x0110,
        pEp_INIT_GPGME_INIT_FAILED = 0x0111,
        pEp_INIT_NO_GPG_HOME = 0x0112,
        pEp_INIT_NETPGP_INIT_FAILED = 0x0113,

        pEp_INIT_SQLITE3_WITHOUT_MUTEX = 0x0120,
        pEp_INIT_CANNOT_OPEN_DB = 0x0121,
        pEp_INIT_CANNOT_OPEN_SYSTEM_DB = 0x0122,

        pEp_KEY_NOT_FOUND = 0x0201,
        pEp_KEY_HAS_AMBIG_NAME = 0x0202,
        pEp_GET_KEY_FAILED = 0x0203,

        pEp_CANNOT_FIND_IDENTITY = 0x0301,
        pEp_CANNOT_SET_PERSON = 0x0381,
        pEp_CANNOT_SET_PGP_KEYPAIR = 0x0382,
        pEp_CANNOT_SET_IDENTITY = 0x0383,
        pEp_CANNOT_SET_TRUST = 0x0384,

        pEp_UNENCRYPTED = 0x0400,
        pEp_VERIFIED = 0x0401,
        pEp_DECRYPTED = 0x0402,
        pEp_DECRYPTED_AND_VERIFIED = 0x0403,
        pEp_DECRYPT_WRONG_FORMAT = 0x0404,
        pEp_DECRYPT_NO_KEY = 0x0405,
        pEp_DECRYPT_SIGNATURE_DOES_NOT_MATCH = 0x0406,
        pEp_VERIFY_NO_KEY = 0x0407,
        pEp_VERIFIED_AND_TRUSTED = 0x0408,
        pEp_CANNOT_DECRYPT_UNKNOWN = 0x04ff,

        pEp_TRUSTWORD_NOT_FOUND = 0x0501,

        pEp_CANNOT_CREATE_KEY = 0x0601,
        pEp_CANNOT_SEND_KEY = 0x0602,

        pEp_PHRASE_NOT_FOUND = 0x0701,

        pEp_COMMIT_FAILED = 0xff01,

        pEp_CANNOT_CREATE_TEMP_FILE = -5,
        pEp_ILLEGAL_VALUE = -4,
        pEp_BUFFER_TOO_SMALL = -3,
        pEp_OUT_OF_MEMORY = -2,
        pEp_UNKNOWN_ERROR = -1
    } pEp_STATUS;

    HRESULT log([in] BSTR title, [in] BSTR entity, [in, defaultvalue("")] BSTR description, [in, defaultvalue("")] BSTR comment);
    HRESULT decrypt([in] BSTR ctext, [out] BSTR * ptext, [out] SAFEARRAY(BSTR) * key_list, [out, retval] pEp_STATUS * decrypt_status);
    HRESULT decrypt_b([in] BSTR ctext, [out] SAFEARRAY(BYTE) * ptext, [out] SAFEARRAY(BSTR) * key_list, [out, retval] pEp_STATUS * decrypt_status);
    HRESULT encrypt([in] SAFEARRAY(BSTR) key_list, [in] BSTR ptext, [out] BSTR * ctext, [out, retval] pEp_STATUS * status);
    HRESULT encrypt_b([in] SAFEARRAY(BSTR) key_list, [in] SAFEARRAY(BYTE) ptext, [out] BSTR * ctext, [out, retval] pEp_STATUS * status);
    HRESULT verify([in] BSTR text, [in] BSTR signature, [out] SAFEARRAY(BSTR) * key_list, [out, retval] pEp_STATUS * verify_status);
    HRESULT trustword([in] LONG value, [in, defaultvalue("en")] BSTR lang, [out, retval] BSTR * word);
    HRESULT trustwords([in] BSTR fpr, [in, defaultvalue("en")] BSTR lang, [in, defaultvalue(0)] LONG max_words, [out, retval] BSTR * words);
    HRESULT get_crashdump_log([in, defaultvalue(0)] LONG maxlines, [out, retval] BSTR * log);
    HRESULT get_languagelist([out, retval] BSTR * languages);
    HRESULT get_phrase([in] BSTR lang, [in] LONG phrase_id, [out, retval] BSTR * phrase);

    typedef enum _pEp_comm_type {
        pEp_ct_unknown = 0,

        // range 0x01 to 0x09: no encryption, 0x0a to 0x0e: nothing reasonable

        pEp_ct_no_encryption = 0x01,                // generic
        pEp_ct_no_encrypted_channel = 0x02,
        pEp_ct_key_not_found = 0x03,
        pEp_ct_key_expired = 0x04,
        pEp_ct_key_revoked = 0x05,
        pEp_ct_key_b0rken = 0x06,
        pEp_ct_my_key_not_included = 0x09,

        pEp_ct_security_by_obscurity = 0x0a,
        pEp_ct_b0rken_crypto = 0x0b,
        pEp_ct_key_too_short = 0x0c,

        pEp_ct_compromized = 0x0e,                  // known compromized connection
        pEp_ct_mistrusted = 0x0f,                   // known mistrusted key

        // range 0x10 to 0x3f: unconfirmed encryption

        pEp_ct_unconfirmed_encryption = 0x10,       // generic
        pEp_ct_OpenPGP_weak_unconfirmed = 0x11,     // RSA 1024 is weak

        pEp_ct_to_be_checked = 0x20,                // generic
        pEp_ct_SMIME_unconfirmed = 0x21,
        pEp_ct_CMS_unconfirmed = 0x22,

        pEp_ct_strong_but_unconfirmed = 0x30,       // generic
        pEp_ct_OpenPGP_unconfirmed = 0x38,          // key at least 2048 bit RSA or EC
        pEp_ct_OTR_unconfirmed = 0x3a,

        // range 0x40 to 0x7f: unconfirmed encryption and anonymization

        pEp_ct_unconfirmed_enc_anon = 0x40,         // generic
        pEp_ct_pEp_unconfirmed = 0x7f,

        pEp_ct_confirmed = 0x80,                    // this bit decides if trust is confirmed

        // range 0x81 to 0x8f: reserved
        // range 0x90 to 0xbf: confirmed encryption

        pEp_ct_confirmed_encryption = 0x90,         // generic
        pEp_ct_OpenPGP_weak = 0x91,                 // RSA 1024 is weak

        pEp_ct_to_be_checked_confirmed = 0xa0,      //generic
        pEp_ct_SMIME = 0xa1,
        pEp_ct_CMS = 0xa2,

        pEp_ct_strong_encryption = 0xb0,            // generic
        pEp_ct_OpenPGP = 0xb8,                      // key at least 2048 bit RSA or EC
        pEp_ct_OTR = 0xba,

        // range 0xc0 to 0xff: confirmed encryption and anonymization

        pEp_ct_confirmed_enc_anon = 0xc0,           // generic
        pEp_ct_pEp = 0xff
    } pEp_comm_type;

    [uuid(0CB90E62-8A6A-4CA0-99D7-481704051FF0)] struct pEp_identity_s {
        BSTR address;
        BSTR fpr;
        BSTR user_id;
        BSTR username;
        pEp_comm_type comm_type;
        BSTR lang;
    };

    HRESULT get_identity([in] BSTR address, [out, retval] struct pEp_identity_s * ident);
    HRESULT set_identity([in] struct pEp_identity_s * ident);
    HRESULT generate_keypair([in] struct pEp_identity_s * ident, [out, retval] BSTR * fpr);
    HRESULT delete_keypair([in] BSTR fpr);
    HRESULT import_key([in] BSTR key_data);
    HRESULT import_key_b([in] SAFEARRAY(BYTE) key_data);
    HRESULT export_key([in] BSTR fpr, [out, retval] BSTR * key_data);
    HRESULT recv_key([in] BSTR pattern);
    HRESULT find_keys([in] BSTR pattern, [out, retval] SAFEARRAY(BSTR) * key_list);
    HRESULT send_key([in] BSTR pattern);

    HRESULT start_keyserver_lookup();
    HRESULT stop_keyserver_lookup();

    HRESULT examine_identity([in] struct pEp_identity_s * ident);
    HRESULT myself([in] struct pEp_identity_s *ident, [out, retval] struct pEp_identity_s *result);
    HRESULT update_identity([in] struct pEp_identity_s *ident, [out, retval] struct pEp_identity_s *result);
    HRESULT key_compromized([in] struct pEp_identity_s *ident);
    HRESULT key_reset_trust([in] struct pEp_identity_s *ident);
    HRESULT trust_personal_key([in] struct pEp_identity_s *ident, [out, retval] struct pEp_identity_s *result);

    // Blacklist API

    HRESULT blacklist_add([in] BSTR fpr);
    HRESULT blacklist_delete([in] BSTR fpr);
    HRESULT blacklist_is_listed([in] BSTR fpr, [out, retval] VARIANT_BOOL *listed);
    HRESULT blacklist_retrieve([out, retval] SAFEARRAY(BSTR) *blacklist);

    // Message API

    typedef enum _pEp_color {
        pEp_rating_undefined = 0,
        pEp_rating_cannot_decrypt,
        pEp_rating_have_no_key,
        pEp_rating_unencrypted,
        pEp_rating_unencrypted_for_some,
        pEp_rating_unreliable,
        pEp_rating_reliable,
        pEp_rating_yellow = pEp_rating_reliable,
        pEp_rating_trusted,
        pEp_rating_green = pEp_rating_trusted,
        pEp_rating_trusted_and_anonymized,
        pEp_rating_fully_anonymous,

        pEp_rating_mistrust = -1,
        pEp_rating_red = pEp_rating_mistrust,
        pEp_rating_b0rken = -2,
        pEp_rating_under_attack = -3
    } pEp_color;

    typedef enum _pEp_text_format {
        pEp_text_format_plain = 0,
        pEp_text_format_html,
        pEp_text_format_other = 0xff
    } pEp_text_format;

    typedef  enum _pEp_msg_direction {
        pEp_dir_incoming = 0,
        pEp_dir_outgoing
    } pEp_msg_direction;

    typedef  enum _pEp_enc_format {
        pEp_enc_none = 0,                       // message is not encrypted
        pEp_enc_pieces,                         // inline PGP + PGP extensions
        pEp_enc_S_MIME,                         // RFC5751
        pEp_enc_PGP_MIME,                       // RFC3156
        pEp_enc_pEp                             // pEp encryption format
    } pEp_enc_format;

    [uuid(3A8A4F13-3402-4C4C-94AB-598D87869380)] struct opt_field {
        BSTR name;
        BSTR value;
    };

    [uuid(61DA7AD4-192E-4616-8678-B19AEFB45B45)] struct blob {
        SAFEARRAY(BYTE) value;
        BSTR mime_type;
        BSTR filename;
    };

    [uuid(D763A8F3-BA23-4229-A037-1BB7BDC3E0C8)] struct text_message {
        pEp_msg_direction dir;
        BSTR id;
        BSTR shortmsg;
        BSTR longmsg;
        BSTR longmsg_formatted;
        SAFEARRAY(struct blob) attachments;
        hyper sent;
        hyper recv;
        struct pEp_identity_s from;
        SAFEARRAY(struct pEp_identity_s) to;
        struct pEp_identity_s recv_by;
        SAFEARRAY(struct pEp_identity_s) cc;
        SAFEARRAY(struct pEp_identity_s) bcc;
        SAFEARRAY(struct pEp_identity_s) reply_to;
        SAFEARRAY(BSTR) references;
        SAFEARRAY(BSTR) keywords;
        BSTR comments;
        SAFEARRAY(struct opt_field) opt_fields;
    };

    HRESULT attach_own_key([in] struct text_message *src, [out] struct text_message * dst);
    HRESULT encrypt_message([in] struct text_message *src, [out] struct text_message * dst, [in] SAFEARRAY(BSTR) extra);
    HRESULT decrypt_message([in] struct text_message *src, [out] struct text_message * dst, [out] SAFEARRAY(BSTR) *keylist, [out, retval] pEp_color *rating);
    HRESULT outgoing_message_color([in] struct text_message *msg, [out, retval] pEp_color * pVal);
    HRESULT identity_color([in] struct pEp_identity_s * ident, [out, retval] pEp_color * pVal);
};

[
    uuid(3EC2E1A4-40E8-48E4-A7B0-1876D34F9462),
    version(1.0),
]
library pEpCOMServerAdapterLib
{
    importlib("stdole2.tlb");
    [
        uuid(B6BC9B8E-D9E2-4419-A3A4-7B4B58175549)
    ]
    dispinterface _IpEpEngineEvents
    {
    properties:
    methods:
    };
    [
        uuid(EF1B073D-5058-4E0E-829E-B4D22CA21EA2)
    ]
    coclass pEpEngine {
        [default] interface IpEpEngine;
        [default, source] dispinterface _IpEpEngineEvents;
    };
};
