// pEpCOMServerAdapter.idl : IDL source for pEpCOMServerAdapter
//

// This file will be processed by the MIDL tool to
// produce the type library (pEpCOMServerAdapter.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";

[
    object,
    uuid(4DA92647-A858-448E-B01F-BE4DCB8C86A1),
    oleautomation,
    nonextensible,
    pointer_default(unique)
]
interface IpEpEngineCallbacks : IUnknown {
    typedef [v1_enum] enum SyncHandshakeSignal {
        SyncNotifyUndefined = 0,

        // request show handshake dialog
        SyncNotifyInitAddOurDevice = 1,
        SyncNotifyInitAddOtherDevice = 2,
        SyncNotifyInitFormGroup = 3,
        SyncNotifyInitMoveOurDevice = 4,

        // handshake process timed out
        SyncNotifyTimeout = 5,

        // handshake accepted by user
        SyncNotifyAcceptedDeviceAdded = 6,
        SyncNotifyAcceptedGroupCreated = 7,
        SyncNotifyAcceptedDeviceMoved = 8,

        // handshake dialog must be closed
        SyncNotifyOvertaken = 9,
    } SyncHandshakeSignal;

    typedef [v1_enum] enum SyncHandshakeResult {
        SyncHandshakeCancel = -1,
        SyncHandshakeAccepted = 0,
        SyncHandshakeRejected = 1
    } SyncHandshakeResult;

    [id(1)] HRESULT MessageToSend([in] struct TextMessage * msg);
    [id(2)] HRESULT NotifyHandshake([in] struct pEpIdentity * self, [in] struct pEpIdentity * partner, [in] SyncHandshakeSignal signal, [out, retval] SyncHandshakeResult * result);
};

[
    object,
    uuid(64E964B2-880A-4E92-B0B5-66FF4286A3B3),
    oleautomation,
    nonextensible,
    pointer_default(unique)
]
interface IpEpEngineCallbacks2 : IpEpEngineCallbacks 
{
    [id(3)] HRESULT NeedFastPolling([in] VARIANT_BOOL enableFastPolling);
};

[
    object,
    uuid(045E49AF-0975-4876-A53B-8CA5AB28C0F8),
    oleautomation,
    nonextensible,
    pointer_default(unique)
]
interface IpEpEngine : IUnknown {

    // runtime config of the adapter

    HRESULT VerboseLogging([in] VARIANT_BOOL enable);

    // runtime config of the engine

    HRESULT PassiveMode([in] VARIANT_BOOL enable);
    HRESULT UnencryptedSubject([in] VARIANT_BOOL enable);

    // basic API

    HRESULT ExportKey([in] BSTR fpr, [out, retval] BSTR * keyData);
    HRESULT Log([in] BSTR title, [in] BSTR entity, [in, defaultvalue("")] BSTR description, [in, defaultvalue("")] BSTR comment);
    HRESULT Trustwords([in] BSTR fpr, [in, defaultvalue("en")] BSTR lang, [in, defaultvalue(0)] LONG maxWords, [out, retval] BSTR * words);
    HRESULT GetTrustwords([in] struct pEpIdentity * id1, [in] struct pEpIdentity * id2, [in, defaultvalue("en")] BSTR lang, [in, defaultvalue(0)] VARIANT_BOOL full, [out, retval] BSTR * words);
    HRESULT GetCrashdumpLog([in, defaultvalue(0)] LONG maxlines, [out, retval] BSTR * log);
    HRESULT GetEngineVersion([out, retval] BSTR * engineVersion);
    HRESULT GetLanguageList([out, retval] BSTR * languages);

    typedef [v1_enum] enum pEpComType {
        pEpCtUnknown = 0,

        // range 0x01 to 0x09: no encryption, 0x0a to 0x0e: nothing reasonable

        pEpCtNoEncryption = 0x01,                // generic
        pEpCtNoEncryptedChannel = 0x02,
        pEpCtKeyNotFound = 0x03,
        pEpCtKeyExpired = 0x04,
        pEpCtKeyRevoked = 0x05,
        pEpCtKeyB0rken = 0x06,
        pEpCtMyKeyNotIncluded = 0x09,

        pEpCtSecurityByObscurity = 0x0a,
        pEpCtB0rkenCrypto = 0x0b,
        pEpCtKeyTooShort = 0x0c,

        pEpCtCompromised = 0x0e,                 // known compromized connection
        pEpCtMistrusted = 0x0f,                  // known mistrusted key

        // range 0x10 to 0x3f: unconfirmed encryption

        pEpCtUnconfirmedEncryption = 0x10,       // generic
        pEpCtOpenPGPWeakUnconfirmed = 0x11,      // RSA 1024 is weak

        pEpCtToBeChecked = 0x20,                 // generic
        pEpCtSMIMEUnconfirmed = 0x21,
        pEpCtCMSUnconfirmed = 0x22,

        pEpCtStrongButUnconfirmed = 0x30,        // generic
        pEpCtOpenPGPUnconfirmed = 0x38,          // key at least 2048 bit RSA or EC
        pEpCtOTRUnconfirmed = 0x3a,

        // range 0x40 to 0x7f: unconfirmed encryption and anonymization

        pEpCtUnconfirmedEncAnon = 0x40,          // generic
        pEpCtpEpUnconfirmed = 0x7f,

        pEpCtConfirmed = 0x80,                   // this bit decides if trust is confirmed

        // range 0x81 to 0x8f: reserved
        // range 0x90 to 0xbf: confirmed encryption

        pEpCtConfirmedEncryption = 0x90,         // generic
        pEpCtOpenPGPWeak = 0x91,                 // RSA 1024 is weak

        pEpCtToBeCheckedConfirmed = 0xa0,        // generic
        pEpCtSMIME = 0xa1,
        pEpCtCMS = 0xa2,

        pEpCtStrongEncryption = 0xb0,            // generic
        pEpCtOpenPGP = 0xb8,                     // key at least 2048 bit RSA or EC
        pEpCtOTR = 0xba,

        // range 0xc0 to 0xff: confirmed encryption and anonymization

        pEpCtConfirmedEncAnon = 0xc0,            // generic
        pEpCtpEp = 0xff
    } pEpComType;

    typedef [v1_enum] enum pEpIdentityFlags {
        pEpIdfNone = 0,
        pEpIdfNotForSync = 0x0001,
        pEpIdfList = 0x0002,
        pEpIdfDevicegroup = 0x0100
    } pEpIdentityFlags;

    [uuid(C3A3814E-567F-4D1C-9F44-9B1DA3957A89)] struct pEpIdentity {
        BSTR Address;
        BSTR Fpr;
        BSTR UserId;
        BSTR UserName;
        pEpComType CommType;
        BSTR Lang;
        pEpIdentityFlags Flags;
    };

    HRESULT SetIdentityFlags([in] struct pEpIdentity *identity, [in] pEpIdentityFlags flags);
    HRESULT UnsetIdentityFlags([in] struct pEpIdentity *identity, [in] pEpIdentityFlags flags);

    // Keymanagement API

    HRESULT StartKeyserverLookup();
    HRESULT StopKeyserverLookup();

    HRESULT Myself([in] struct pEpIdentity *ident, [out, retval] struct pEpIdentity *result);
    HRESULT UpdateIdentity([in] struct pEpIdentity *ident, [out, retval] struct pEpIdentity *result);
    HRESULT KeyMistrusted([in] struct pEpIdentity *ident);
    HRESULT KeyResetTrust([in] struct pEpIdentity *ident);
    HRESULT TrustPersonalKey([in] struct pEpIdentity *ident, [out, retval] struct pEpIdentity *result);
    HRESULT OwnIdentitiesRetrieve([out, retval] SAFEARRAY(struct pEpIdentity)* ownIdentities);

    // Blacklist API

    HRESULT BlacklistAdd([in] BSTR fpr);
    HRESULT BlacklistDelete([in] BSTR fpr);
    HRESULT BlacklistIsListed([in] BSTR fpr, [out, retval] VARIANT_BOOL *listed);
    HRESULT BlacklistRetrieve([out, retval] SAFEARRAY(BSTR) *blacklist);

    // PGP compatibility functions

    HRESULT OpenPGPListKeyinfo([in] BSTR searchPattern, [out, retval] SAFEARRAY(struct StringPair)* keyinfoList);

    // Message API

    typedef [v1_enum] enum pEpRating {
        pEpRatingUndefined = 0,
        pEpRatingCannotDecrypt,
        pEpRatingHaveNoKey,
        pEpRatingUnencrypted,
        pEpRatingUnencryptedForSome,
        pEpRatingUnreliable,
        pEpRatingReliable,
        pEpRatingTrusted,
        pEpRatingTrustedAndAnonymized,
        pEpRatingFullyAnonymous,

        pEpRatingMistrust = -1,
        pEpRatingB0rken = -2,
        pEpRatingUnderAttack = -3
    } pEpRating;

    typedef [v1_enum] enum pEpColor {
        pEpColorNoColor = 0,
        pEpColorYellow,
        pEpColorGreen,
        pEpColorRed = -1,
    } pEpColor;

    typedef [v1_enum] enum pEpEncryptFlags {
        pEpEncryptFlagDefault = 0,
        pEpEncryptFlagForceEncryption = 0x1,

        // This flag is for special uses and should not be used
        // by normal pEp clients!
        pEpEncryptFlagForceUnsigned = 0x2,

        // This flag is for special uses and should not be used
        // by normal pEp clients!
        pEpEncryptFlagForceNoAttachedKey = 0x4,

    } pEpEncryptFlags;

    typedef [v1_enum] enum pEpDecryptFlags {
        pEpDecryptFlagsNone = 0,
        pEpDecryptFlagOwnPrivateKey = 0x1,
        pEpDecryptFlagConsume = 0x2,
        pEpDecryptFlagIgnore = 0x4
    } pEpDecryptFlags;

    typedef [v1_enum] enum pEpMsgDirection {
        pEpDirIncoming = 0,
        pEpDirOutgoing
    } pEpMsgDirection;

    [uuid(47FB0795-6B64-455C-BB0E-54998CAB8ACB)] struct StringPair {
        BSTR Name;
        BSTR Value;
    };

    [uuid(634EB7CE-99AA-460D-BDF8-F7CDA7232CA6)] struct Blob {
        SAFEARRAY(BYTE) value;
        BSTR MimeType;
        BSTR Filename;
    };

    [uuid(B6F40887-E761-4A47-B204-A0193EE0284D)] struct TextMessage {
        pEpMsgDirection Dir;
        BSTR Id;
        BSTR ShortMsg;
        BSTR LongMsg;
        BSTR LongMsgFormatted;
        SAFEARRAY(struct Blob) Attachments;
        hyper Sent; // Timestamp: 64 Bit time_t from mktime(), seconds since January 1, 1970, 0:00 UTC.
        hyper Recv; // Timestamp: 64 Bit time_t from mktime(), seconds since January 1, 1970, 0:00 UTC.
        struct pEpIdentity From;
        SAFEARRAY(struct pEpIdentity) To;
        struct pEpIdentity RecvBy;
        SAFEARRAY(struct pEpIdentity) Cc;
        SAFEARRAY(struct pEpIdentity) Bcc;
        SAFEARRAY(struct pEpIdentity) ReplyTo;
        SAFEARRAY(BSTR) References;
        SAFEARRAY(BSTR) Keywords;
        BSTR Comments;
        SAFEARRAY(struct StringPair) OptFields;
    };

    HRESULT EncryptMessage(
        [in] struct TextMessage *src,
        [out] struct TextMessage * dst,
        [in] SAFEARRAY(BSTR) extra,
        [in, defaultvalue(pEpEncryptFlagDefault)] pEpEncryptFlags flags);

    HRESULT DecryptMessage(
        [in] struct TextMessage *src,
        [out] struct TextMessage * dst,
        [out] SAFEARRAY(BSTR) *keylist,
        [out] pEpDecryptFlags* flags,
        [out, retval] pEpRating *rating);

    HRESULT OutgoingMessageRating([in] struct TextMessage *msg, [out, retval] pEpRating * pVal);
    HRESULT IdentityRating([in] struct pEpIdentity * ident, [out, retval] pEpRating * pVal);
    HRESULT ColorFromRating([in] pEpRating rating, [out, retval] pEpColor* pVal);

    // callback / keysync API
    HRESULT RegisterCallbacks([in] IpEpEngineCallbacks* newCallback);
    HRESULT UnregisterCallbacks();
};

[
    object,
    uuid(8A042123-D433-4DEA-ADA2-2E5E61A00292),
    oleautomation,
    nonextensible,
    pointer_default(unique)
]
interface IpEpEngine2 : IpEpEngine
{
    HRESULT GetMessageTrustwords(
        [in] struct TextMessage *msg,
        [in] struct pEpIdentity * receivedBy,
        [in] SAFEARRAY(BSTR) keylist,
        [in, defaultvalue("en")] BSTR lang,
        [in, defaultvalue(0)] VARIANT_BOOL full,
        [out, retval] BSTR * words
    );

    HRESULT EncryptMessageForSelf(
        [in] struct pEpIdentity* targetId,
        [in] struct TextMessage* src, 
        [out] struct TextMessage* dst,
        [in, defaultvalue(pEpEncryptFlagDefault)] pEpEncryptFlags flags
    );

    HRESULT ReEvaluateMessageRating(
        [in] struct TextMessage *src,
        [in] SAFEARRAY(BSTR) x_KeyList, // referring to X-KeyList mail header
        [in] pEpRating x_EncStatus, // referring to X-EncStatus mail header
        [out, retval] pEpRating *rating
    );

	HRESULT UndoLastMistrust();

	HRESULT SetOwnKey(
		[in] struct pEpIdentity * ident,
		[in] BSTR fpr,
		[out, retval] struct pEpIdentity * result
	);
};

[
    uuid(564A4350-419E-47F1-B0DF-6FCCF0CD0BBC),
    version(1.0),
]
library pEpCOMServerAdapterLib
{
    importlib("stdole2.tlb");

    [
        uuid(5FF6682B-727B-4DFE-A68D-28982874C0C7)
    ]
    coclass pEpEngine {
        [default] interface IpEpEngine2;
        interface IpEpEngine;
        interface IpEpEngineCallbacks2;
    };
};
